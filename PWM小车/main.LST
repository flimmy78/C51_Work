C51 COMPILER V9.01   MAIN                                                                  06/09/2012 23:49:48 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.C BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /**************************************************
   2          À´Ô´£ºÍøÉÏ
   3          ¸ÄÐ´£ºbluefeel
   4          Ê±¼ä£º10-03-13
   5          µ¥Î»£º¹ðÁÖÀí¹¤´óÑ§
   6          
   7          STATUS   
   8          7 Ä¬ÈÏÎª0
   9          6 ½ÓÊÕÊý¾ÝÖÐ¶Ï¡£µ±½ÓÊÕµ½ÓÐÐ§Êý¾ÝºóÖÃ1.Ð´1Çå³ýÖÐ¶Ï
  10          5 Êý¾Ý·¢ËÍÍê³ÉÖÐ¶Ï¡£µ±Êý¾Ý·¢ËÍÍê³Éºó²úÉúÖÐ¶Ï¡£Èç¹û¹¤×÷ÔÚ×Ô¶¯Ó¦´ðÄ£Ê½ÏÂÖ»ÓÐµ±½ÓÊÕµ½Ó¦´ðÐÅºÅºóÖÃ1
  11          4 ´ïµ½×î¶à´ÎÖØ·¢ÖÐ¶Ï¡£Ð´1Çå³ýÖÐ¶Ï£¬Èç¹û´ËÎ»ÖÃ1ÁËÔò±ØÐëÇå³ý²ÅÄÜ¼ÌÐøÍ¨Ñ¶
  12          3£º1 ½ÓÊÕÊý¾ÝÍ¨µÀºÅ 000-101 Êý¾ÝÍ¨µÀºÅ 110 Î´Ê¹ÓÃ 111£ºRX FIFO¼Ä´æÆ÷Îª¿Õ
  13          0 TX FIFO¼Ä´æÆ÷Âú±êÖ¾ 1£ºTX FIFO ¼Ä´æÆ÷Âú 0£ºTX FIFO¼Ä´æÆ÷Î´Âú
  14          
  15          
  16          /**************************************************/
  17          
  18          #include <reg52.h>
  19          #include <intrins.h>
  20          #include <api.h>
  21          #include <uart.h>
  22          
  23          #define uchar unsigned char
  24          
  25          /***************************************************/
  26          #define TX_ADR_WIDTH   4  // 4×Ö½Ú¿í¶ÈµÄ·¢ËÍ/½ÓÊÕµØÖ·
  27          #define TX_PLOAD_WIDTH 20  // Êý¾ÝÍ¨µÀÓÐÐ§Êý¾Ý¿í¶È£¨fifo×Ö½Ú£©
  28          sbit p10 = P2^0;
  29          sbit p11 = P2^1;
  30          sbit p12 = P2^2;
  31          sbit p13 = P2^3;
  32          uchar j = 0;
  33          uint count=1000;
  34          uchar cmd;
  35          uchar turn=0;
  36          uchar left=0;
  37          uchar right=0;
  38          uchar code TX_ADDRESS[TX_ADR_WIDTH] = {0xC0,0xEE,0xD2,0xA2};  // ¶¨ÒåÒ»¸ö¾²Ì¬·¢ËÍµØÖ·
  39          uchar RX_BUF[TX_PLOAD_WIDTH];
  40          uchar TX_BUF[TX_PLOAD_WIDTH];
  41          uchar flag;
  42          uchar DATA = 0x26;
  43          uchar bdata sta;
  44          sbit  RX_DR      = sta^6;
  45          sbit  TX_DS      = sta^5;
  46          sbit  MAX_RT = sta^4;
  47          char  delay = 1500;
  48          /**************************************************/
  49          
  50          /**************************************************
  51          º¯Êý: init_io()
  52          
  53          ÃèÊö:
  54              ³õÊ¼»¯IO
  55          /**************************************************/
C51 COMPILER V9.01   MAIN                                                                  06/09/2012 23:49:48 PAGE 2   

  56          void init_io(void)
  57          {
  58   1              CE  = 0;        // ´ý»ú
  59   1              CSN = 1;        // SPI½ûÖ¹
  60   1              SCK = 0;        // SPIÊ±ÖÓÖÃµÍ
  61   1              IRQ = 1;        // ÖÐ¶Ï¸´Î»
  62   1      }
  63          /**************************************************/
  64          
  65          /**************************************************
  66          º¯Êý£ºdelay_ms()
  67          
  68          ÃèÊö£º
  69              ÑÓ³ÙxºÁÃë
  70          /**************************************************/
  71          void delay_ms(uchar x)
  72          {
  73   1          uchar i, j;
  74   1          i = 0;
  75   1          for(i=0; i<x; i++)
  76   1          {
  77   2             j = 250;
  78   2             while(--j);
  79   2                 j = 250;
  80   2             while(--j);
  81   2          }
  82   1      }
  83          /**************************************************/
  84          
  85          /**************************************************
  86          º¯Êý£ºSPI_RW()
  87          
  88          ÃèÊö£º
  89              ¸ù¾ÝSPIÐ­Òé£¬Ð´Ò»×Ö½ÚÊý¾Ýµ½nRF24L01£¬Í¬Ê±´ÓnRF24L01
  90                  ¶Á³öÒ»×Ö½Ú
  91          /**************************************************/
  92          uchar SPI_RW(uchar byte)
  93          {
  94   1              uchar i;
  95   1              for(i=0; i<8; i++)          // Ñ­»·8´Î
  96   1              {
  97   2                      MOSI = (byte & 0x80);   // byte×î¸ßÎ»Êä³öµ½MOSI
  98   2                      byte <<= 1;             // µÍÒ»Î»ÒÆÎ»µ½×î¸ßÎ»
  99   2                      SCK = 1;                // À­¸ßSCK£¬nRF24L01´ÓMOSI¶ÁÈë1Î»Êý¾Ý£¬Í¬Ê±´ÓMISOÊä³ö1Î»Êý¾Ý
 100   2                      byte |= MISO;           // ¶ÁMISOµ½byte×îµÍÎ»
 101   2                      SCK = 0;                // SCKÖÃµÍ
 102   2              }
 103   1          return(byte);               // ·µ»Ø¶Á³öµÄÒ»×Ö½Ú
 104   1      }
 105          /**************************************************/
 106          
 107          /**************************************************
 108          º¯Êý£ºSPI_RW_Reg()
 109          
 110          ÃèÊö£º
 111              Ð´Êý¾Ývalueµ½reg¼Ä´æÆ÷
 112          /**************************************************/
 113          uchar SPI_RW_Reg(uchar reg, uchar value)
 114          {
 115   1              uchar status;
 116   1              CSN = 0;                   // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 117   1              status = SPI_RW(reg);      // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
C51 COMPILER V9.01   MAIN                                                                  06/09/2012 23:49:48 PAGE 3   

 118   1              SPI_RW(value);             // È»ºóÐ´Êý¾Ýµ½¸Ã¼Ä´æÆ÷
 119   1              CSN = 1;                   // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 120   1              return(status);            // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 121   1      }
 122          /**************************************************/
 123          
 124          /**************************************************
 125          º¯Êý£ºSPI_Read()
 126          
 127          ÃèÊö£º
 128              ´Óreg¼Ä´æÆ÷¶ÁÒ»×Ö½Ú
 129          /**************************************************/
 130          uchar SPI_Read(uchar reg)
 131          {
 132   1              uchar reg_val;
 133   1              CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 134   1              SPI_RW(reg);                // Ñ¡Ôñ¼Ä´æÆ÷
 135   1              reg_val = SPI_RW(0);        // È»ºó´Ó¸Ã¼Ä´æÆ÷¶ÁÊý¾Ý
 136   1              CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 137   1              return(reg_val);            // ·µ»Ø¼Ä´æÆ÷Êý¾Ý
 138   1      }
 139          /**************************************************/
 140          
 141          /**************************************************
 142          º¯Êý£ºSPI_Read_Buf()
 143          
 144          ÃèÊö£º
 145              ´Óreg¼Ä´æÆ÷¶Á³öbytes¸ö×Ö½Ú£¬Í¨³£ÓÃÀ´¶ÁÈ¡½ÓÊÕÍ¨µÀ
 146                  Êý¾Ý»ò½ÓÊÕ/·¢ËÍµØÖ·
 147          /**************************************************/
 148          uchar SPI_Read_Buf(uchar reg, uchar * pBuf, uchar bytes)
 149          {
 150   1              uchar status, i;
 151   1              CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 152   1              status = SPI_RW(reg);       // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
 153   1              for(i=0; i<bytes; i++)
 154   1              pBuf[i] = SPI_RW(0);    // Öð¸ö×Ö½Ú´ÓnRF24L01¶Á³ö
 155   1              CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 156   1              return(status);             // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 157   1      }
 158          /**************************************************/
 159          
 160          /**************************************************
 161          º¯Êý£ºSPI_Write_Buf()
 162          
 163          ÃèÊö£º
 164              °ÑpBuf»º´æÖÐµÄÊý¾ÝÐ´Èëµ½nRF24L01£¬Í¨³£ÓÃÀ´Ð´Èë·¢
 165                  ÉäÍ¨µÀÊý¾Ý»ò½ÓÊÕ/·¢ËÍµØÖ·
 166          /**************************************************/
 167          uchar SPI_Write_Buf(uchar reg, uchar * pBuf, uchar bytes)
 168          {
 169   1              uchar status, i;
 170   1              CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 171   1              status = SPI_RW(reg);       // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
 172   1              for(i=0; i<bytes; i++)
 173   1              SPI_RW(pBuf[i]);        // Öð¸ö×Ö½ÚÐ´ÈënRF24L01
 174   1              CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 175   1              return(status);             // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 176   1      }
 177          /**************************************************/
 178          
 179          /**************************************************
C51 COMPILER V9.01   MAIN                                                                  06/09/2012 23:49:48 PAGE 4   

 180          º¯Êý£ºRX_Mode()
 181          
 182          ÃèÊö£º
 183              Õâ¸öº¯ÊýÉèÖÃnRF24L01Îª½ÓÊÕÄ£Ê½£¬µÈ´ý½ÓÊÕ·¢ËÍÉè±¸µÄÊý¾Ý°ü
 184          /**************************************************/
 185          void RX_Mode(void)
 186          {
 187   1                      CE = 0;
 188   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH);  // ½ÓÊÕÉè±¸½ÓÊÕÍ¨µÀ0Ê¹ÓÃºÍ·¢ËÍÉè±¸ÏàÍ
             -¬µÄ·¢ËÍµØÖ·
 189   1              SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);               // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0×Ô¶¯Ó¦´ð
 190   1              SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);           // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0
 191   1              SPI_RW_Reg(WRITE_REG + SETUP_AW, 0x02);                    //ÉèÖÃµØÖ·¿í¶È 1:0 00-ÎÞÐ§ 01-3×Ö½Ú 10-4×Ö½Ú 11 5×Ö½Ú
 192   1                      SPI_RW_Reg(WRITE_REG + RF_CH, 0);                 // Ñ¡ÔñÉäÆµÍ¨µÀ0x40
 193   1              SPI_RW_Reg(WRITE_REG + RX_PW_P0, TX_PLOAD_WIDTH);  // ½ÓÊÕÍ¨µÀ0Ñ¡ÔñºÍ·¢ËÍÍ¨µÀÏàÍ¬ÓÐÐ§Êý¾Ý¿í¶È
 194   1              SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x0F);            // Êý¾Ý´«ÊäÂÊ1Mbps£¬·¢Éä¹¦ÂÊ0dBm£¬µÍÔëÉù·Å´óÆ÷ÔöÒæ
 195   1              SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f);              // CRCÊ¹ÄÜ£¬16Î»CRCÐ£Ñé£¬ÉÏµç£¬½ÓÊÕÄ£Ê½
 196   1              CE = 1;                                            // À­¸ßCEÆô¶¯½ÓÊÕÉè±¸
 197   1              while(delay--);
 198   1              delay = 150;
 199   1      
 200   1      }
 201          /**************************************************/
 202          
 203          /**************************************************
 204          º¯Êý£ºTX_Mode()
 205          
 206          ÃèÊö£º
 207              Õâ¸öº¯ÊýÉèÖÃnRF24L01Îª·¢ËÍÄ£Ê½£¬£¨CE=1³ÖÐøÖÁÉÙ10us£©£¬
 208                  130usºóÆô¶¯·¢Éä£¬Êý¾Ý·¢ËÍ½áÊøºó£¬·¢ËÍÄ£¿é×Ô¶¯×ªÈë½ÓÊÕ
 209                  Ä£Ê½µÈ´ýÓ¦´ðÐÅºÅ¡£
 210          /**************************************************/
 211          void TX_Mode(uchar * BUF)
 212          {
 213   1              CE = 0;
 214   1              SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);     // Ð´Èë·¢ËÍµØÖ·
 215   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH);  // ÎªÁËÓ¦´ð½ÓÊÕÉè±¸£¬½ÓÊÕÍ¨µÀ0µØÖ·ºÍ·
             -¢ËÍµØÖ·ÏàÍ¬
 216   1              SPI_Write_Buf(WR_TX_PLOAD, BUF, TX_PLOAD_WIDTH);                  // Ð´Êý¾Ý°üµ½TX FIFO
 217   1              SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);       // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0×Ô¶¯Ó¦´ð
 218   1              SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);   // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0
 219   1              SPI_RW_Reg(WRITE_REG + SETUP_AW, 0x02);         //ÉèÖÃµØÖ·¿í¶È 1:0 00-ÎÞÐ§ 01-3×Ö½Ú 10-4×Ö½Ú 11 5×Ö½Ú
 220   1              SPI_RW_Reg(WRITE_REG + SETUP_RETR, 0x0a);  // ×Ô¶¯ÖØ·¢ÑÓÊ±µÈ´ý250us+86us£¬×Ô¶¯ÖØ·¢10´Î
 221   1              SPI_RW_Reg(WRITE_REG + RF_CH, 0);         // Ñ¡ÔñÉäÆµÍ¨µÀ0x40
 222   1              SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x0F);    // Êý¾Ý´«ÊäÂÊ2Mbps£¬·¢Éä¹¦ÂÊ0dBm£¬µÍÔëÉù·Å´óÆ÷ÔöÒæ
 223   1              SPI_RW_Reg(WRITE_REG + CONFIG, 0x0e);      // CRCÊ¹ÄÜ£¬16Î»CRCÐ£Ñé£¬ÉÏµç
 224   1              CE = 1;
 225   1              while(delay--);
 226   1              delay = 150;
 227   1      }
 228          /**************************************************/
 229          
 230          /**************************************************
 231          º¯Êý£ºCheck_ACK()
 232          
 233          ÃèÊö£º
 234              ¼ì²é½ÓÊÕÉè±¸ÓÐÎÞ½ÓÊÕµ½Êý¾Ý°ü£¬Éè¶¨Ã»ÓÐÊÕµ½Ó¦´ðÐÅ
 235                  ºÅÊÇ·ñÖØ·¢
 236          /**************************************************/
 237          uchar Check_ACK(bit clear)
 238          {
 239   1              send_string("µÈ´ýirqÖÐ¶Ï");
C51 COMPILER V9.01   MAIN                                                                  06/09/2012 23:49:48 PAGE 5   

 240   1              while(IRQ);
 241   1              send_string("ÖÐ¶Ïºó");
 242   1              sta = SPI_Read(STATUS);
 243   1              //sta = SPI_RW(NOP);
 244   1              if(TX_DS)//Êý¾Ý·¢ËÍÍê³ÉÖÐ¶Ï¡£µ±Êý¾Ý·¢ËÍÍê³Éºó²úÉúÖÐ¶Ï¡£Èç¹û¹¤×÷ÔÚ×Ô¶¯Ó¦´ðÄ£Ê½ÏÂÖ»ÓÐµ±½ÓÊÕµ½Ó¦´ðÐÅºÅºóÖÃ1
 245   1                      send_char('T');
 246   1              else
 247   1                      send_char('F');                    // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 248   1              if(MAX_RT){
 249   2                      if(clear){                                      // ÊÇ·ñÇå³ýTX FIFO£¬Ã»ÓÐÇå³ýÔÚ¸´Î»MAX_RTÖÐ¶Ï±êÖ¾ºóÖØ·¢
 250   3                      send_string("´ïµ½×î´óÖØ·¢Êý");
 251   3                      send_char(SPI_Read(OBSERVE_TX));                     
 252   3                              SPI_RW(FLUSH_TX);
 253   3                      }
 254   2              }
 255   1              SPI_RW_Reg(WRITE_REG + STATUS, sta);  // Çå³ýTX_DS»òMAX_RTÖÐ¶Ï±êÖ¾
 256   1              IRQ = 1;   
 257   1              if(TX_DS)//Êý¾Ý·¢ËÍÍê³ÉÖÐ¶Ï¡£µ±Êý¾Ý·¢ËÍÍê³Éºó²úÉúÖÐ¶Ï¡£Èç¹û¹¤×÷ÔÚ×Ô¶¯Ó¦´ðÄ£Ê½ÏÂÖ»ÓÐµ±½ÓÊÕµ½Ó¦´ðÐÅºÅºóÖÃ1
 258   1                      return(0x54);
 259   1              else
 260   1                      return(0x46);
 261   1      }
 262          /**************************************************/
 263          
 264          /**************************************************
 265          º¯Êý£ºCheckButtons()
 266          
 267          ÃèÊö£º
 268              ¼ì²é°´¼üÊÇ·ñ°´ÏÂ£¬°´ÏÂÔò·¢ËÍÒ»×Ö½ÚÊý¾Ý
 269          /**************************************************/
 270          void CheckButtons()
 271          {
 272   1      
 273   1                              TX_BUF[0] = DATA;          // Êý¾ÝËÍµ½»º´æ
 274   1                              TX_Mode(TX_BUF);                        // °ÑnRF24L01ÉèÖÃÎª·¢ËÍÄ£Ê½²¢·¢ËÍÊý¾Ý
 275   1                              //LED = ~DATA;                  // Êý¾ÝËÍµ½LEDÏÔÊ¾
 276   1                              send_char(Check_ACK(1));               // µÈ´ý·¢ËÍÍê±Ï£¬Çå³ýTX FIFO
 277   1                              //delay_ms(250);
 278   1                              //delay_ms(250);
 279   1                              //LED = 0xff;                           // ¹Ø±ÕLED
 280   1                              RX_Mode();                              // ÉèÖÃÎª½ÓÊÕÄ£Ê½
 281   1                              //while(!(P3 & 0x01));
 282   1                              //DATA <<= 1;
 283   1                              //if(!DATA)
 284   1                              //      DATA = 0x26;
 285   1              
 286   1      }
 287          /**************************************************/
 288          
 289          /**************************************************
 290          º¯Êý£ºmain()
 291          
 292          ÃèÊö£º
 293              Ö÷º¯Êý
 294          /**************************************************/
 295          void main(void)
 296          {
 297   1              uart_init();
 298   1              init_io();                            // ³õÊ¼»¯IO
 299   1              RX_Mode();              
 300   1              while(1)
 301   1              {
C51 COMPILER V9.01   MAIN                                                                  06/09/2012 23:49:48 PAGE 6   

 302   2                       
 303   2                      while(RI)
 304   2                      {         DATA = read_char();
 305   3                                      CheckButtons();           // °´¼üÉ¨Ãè
 306   3                      }
 307   2                      
 308   2                      sta = SPI_Read(STATUS);   // ¶Á×´Ì¬¼Ä´æÆ÷
 309   2                if(RX_DR)                               // ÅÐ¶ÏÊÇ·ñ½ÓÊÜµ½Êý¾Ý
 310   2                      {
 311   3                              //send_string("ÊÕµ½Êý¾Ý");
 312   3                              send_char('&');
 313   3                              SPI_Read_Buf(RD_RX_PLOAD, RX_BUF, TX_PLOAD_WIDTH);  // ´ÓRX FIFO¶Á³öÊý¾Ý
 314   3                              flag = 1;
 315   3                      }
 316   2                      SPI_RW_Reg(WRITE_REG + STATUS, sta);  // Çå³ýRX_DSÖÐ¶Ï±êÖ¾
 317   2                      if(flag)                           // ½ÓÊÜÍê³É
 318   2                      {
 319   3                              flag = 0;                      // Çå±êÖ¾
 320   3                              send_char(RX_BUF[0]);
 321   3                              send_char(';');
 322   3                      }
 323   2              }
 324   1      }
 325          /**************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    605    ----
   CONSTANT SIZE    =     36    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     53      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
