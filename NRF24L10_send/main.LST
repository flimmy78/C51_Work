C51 COMPILER V9.01   MAIN                                                                  06/10/2012 00:20:04 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.C BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /**************************************************
   2          À´Ô´£ºÍøÉÏ
   3          ¸ÄÐ´£ºbluefeel
   4          Ê±¼ä£º10-03-13
   5          µ¥Î»£º¹ðÁÖÀí¹¤´óÑ§
   6          
   7          STATUS   
   8          7 Ä¬ÈÏÎª0
   9          6 ½ÓÊÕÊý¾ÝÖÐ¶Ï¡£µ±½ÓÊÕµ½ÓÐÐ§Êý¾ÝºóÖÃ1.Ð´1Çå³ýÖÐ¶Ï
  10          5 Êý¾Ý·¢ËÍÍê³ÉÖÐ¶Ï¡£µ±Êý¾Ý·¢ËÍÍê³Éºó²úÉúÖÐ¶Ï¡£Èç¹û¹¤×÷ÔÚ×Ô¶¯Ó¦´ðÄ£Ê½ÏÂÖ»ÓÐµ±½ÓÊÕµ½Ó¦´ðÐÅºÅºóÖÃ1
  11          4 ´ïµ½×î¶à´ÎÖØ·¢ÖÐ¶Ï¡£Ð´1Çå³ýÖÐ¶Ï£¬Èç¹û´ËÎ»ÖÃ1ÁËÔò±ØÐëÇå³ý²ÅÄÜ¼ÌÐøÍ¨Ñ¶
  12          3£º1 ½ÓÊÕÊý¾ÝÍ¨µÀºÅ 000-101 Êý¾ÝÍ¨µÀºÅ 110 Î´Ê¹ÓÃ 111£ºRX FIFO¼Ä´æÆ÷Îª¿Õ
  13          0 TX FIFO¼Ä´æÆ÷Âú±êÖ¾ 1£ºTX FIFO ¼Ä´æÆ÷Âú 0£ºTX FIFO¼Ä´æÆ÷Î´Âú
  14          
  15          
  16          /**************************************************/
  17          
  18          #include <reg52.h>
  19          #include <intrins.h>
  20          #include <api.h>
  21          #include <uart.h>
  22          
  23          #define uchar unsigned char
  24          
  25          /***************************************************/
  26          #define TX_ADR_WIDTH   4  // 4×Ö½Ú¿í¶ÈµÄ·¢ËÍ/½ÓÊÕµØÖ·
  27          #define TX_PLOAD_WIDTH 20  // Êý¾ÝÍ¨µÀÓÐÐ§Êý¾Ý¿í¶È£¨fifo×Ö½Ú£©
  28          
  29          uchar code TX_ADDRESS[TX_ADR_WIDTH] = {0xC0,0xEE,0xD2,0xA2};  // ¶¨ÒåÒ»¸ö¾²Ì¬·¢ËÍµØÖ·
  30          uchar RX_BUF[TX_PLOAD_WIDTH];
  31          uchar TX_BUF[TX_PLOAD_WIDTH];
  32          uchar flag;
  33          uchar DATA = 0x26;
  34          uchar bdata sta;
  35          sbit  RX_DR      = sta^6;
  36          sbit  TX_DS      = sta^5;
  37          sbit  MAX_RT = sta^4;
  38          char  delay = 1500;
  39          /**************************************************/
  40          
  41          /**************************************************
  42          º¯Êý: init_io()
  43          
  44          ÃèÊö:
  45              ³õÊ¼»¯IO
  46          /**************************************************/
  47          void init_io(void)
  48          {
  49   1              CE  = 0;        // ´ý»ú
  50   1              CSN = 1;        // SPI½ûÖ¹
  51   1              SCK = 0;        // SPIÊ±ÖÓÖÃµÍ
  52   1              IRQ = 1;        // ÖÐ¶Ï¸´Î»
  53   1      }
  54          /**************************************************/
  55          
C51 COMPILER V9.01   MAIN                                                                  06/10/2012 00:20:04 PAGE 2   

  56          /**************************************************
  57          º¯Êý£ºdelay_ms()
  58          
  59          ÃèÊö£º
  60              ÑÓ³ÙxºÁÃë
  61          /**************************************************/
  62          void delay_ms(uchar x)
  63          {
  64   1          uchar i, j;
  65   1          i = 0;
  66   1          for(i=0; i<x; i++)
  67   1          {
  68   2             j = 250;
  69   2             while(--j);
  70   2                 j = 250;
  71   2             while(--j);
  72   2          }
  73   1      }
  74          /**************************************************/
  75          
  76          /**************************************************
  77          º¯Êý£ºSPI_RW()
  78          
  79          ÃèÊö£º
  80              ¸ù¾ÝSPIÐ­Òé£¬Ð´Ò»×Ö½ÚÊý¾Ýµ½nRF24L01£¬Í¬Ê±´ÓnRF24L01
  81                  ¶Á³öÒ»×Ö½Ú
  82          /**************************************************/
  83          uchar SPI_RW(uchar byte)
  84          {
  85   1              uchar i;
  86   1              for(i=0; i<8; i++)          // Ñ­»·8´Î
  87   1              {
  88   2                      MOSI = (byte & 0x80);   // byte×î¸ßÎ»Êä³öµ½MOSI
  89   2                      byte <<= 1;             // µÍÒ»Î»ÒÆÎ»µ½×î¸ßÎ»
  90   2                      SCK = 1;                // À­¸ßSCK£¬nRF24L01´ÓMOSI¶ÁÈë1Î»Êý¾Ý£¬Í¬Ê±´ÓMISOÊä³ö1Î»Êý¾Ý
  91   2                      byte |= MISO;           // ¶ÁMISOµ½byte×îµÍÎ»
  92   2                      SCK = 0;                // SCKÖÃµÍ
  93   2              }
  94   1          return(byte);               // ·µ»Ø¶Á³öµÄÒ»×Ö½Ú
  95   1      }
  96          /**************************************************/
  97          
  98          /**************************************************
  99          º¯Êý£ºSPI_RW_Reg()
 100          
 101          ÃèÊö£º
 102              Ð´Êý¾Ývalueµ½reg¼Ä´æÆ÷
 103          /**************************************************/
 104          uchar SPI_RW_Reg(uchar reg, uchar value)
 105          {
 106   1              uchar status;
 107   1              CSN = 0;                   // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 108   1              status = SPI_RW(reg);      // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
 109   1              SPI_RW(value);             // È»ºóÐ´Êý¾Ýµ½¸Ã¼Ä´æÆ÷
 110   1              CSN = 1;                   // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 111   1              return(status);            // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 112   1      }
 113          /**************************************************/
 114          
 115          /**************************************************
 116          º¯Êý£ºSPI_Read()
 117          
C51 COMPILER V9.01   MAIN                                                                  06/10/2012 00:20:04 PAGE 3   

 118          ÃèÊö£º
 119              ´Óreg¼Ä´æÆ÷¶ÁÒ»×Ö½Ú
 120          /**************************************************/
 121          uchar SPI_Read(uchar reg)
 122          {
 123   1              uchar reg_val;
 124   1              CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 125   1              SPI_RW(reg);                // Ñ¡Ôñ¼Ä´æÆ÷
 126   1              reg_val = SPI_RW(0);        // È»ºó´Ó¸Ã¼Ä´æÆ÷¶ÁÊý¾Ý
 127   1              CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 128   1              return(reg_val);            // ·µ»Ø¼Ä´æÆ÷Êý¾Ý
 129   1      }
 130          /**************************************************/
 131          
 132          /**************************************************
 133          º¯Êý£ºSPI_Read_Buf()
 134          
 135          ÃèÊö£º
 136              ´Óreg¼Ä´æÆ÷¶Á³öbytes¸ö×Ö½Ú£¬Í¨³£ÓÃÀ´¶ÁÈ¡½ÓÊÕÍ¨µÀ
 137                  Êý¾Ý»ò½ÓÊÕ/·¢ËÍµØÖ·
 138          /**************************************************/
 139          uchar SPI_Read_Buf(uchar reg, uchar * pBuf, uchar bytes)
 140          {
 141   1              uchar status, i;
 142   1              CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 143   1              status = SPI_RW(reg);       // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
 144   1              for(i=0; i<bytes; i++)
 145   1              pBuf[i] = SPI_RW(0);    // Öð¸ö×Ö½Ú´ÓnRF24L01¶Á³ö
 146   1              CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 147   1              return(status);             // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 148   1      }
 149          /**************************************************/
 150          
 151          /**************************************************
 152          º¯Êý£ºSPI_Write_Buf()
 153          
 154          ÃèÊö£º
 155              °ÑpBuf»º´æÖÐµÄÊý¾ÝÐ´Èëµ½nRF24L01£¬Í¨³£ÓÃÀ´Ð´Èë·¢
 156                  ÉäÍ¨µÀÊý¾Ý»ò½ÓÊÕ/·¢ËÍµØÖ·
 157          /**************************************************/
 158          uchar SPI_Write_Buf(uchar reg, uchar * pBuf, uchar bytes)
 159          {
 160   1              uchar status, i;
 161   1              CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 162   1              status = SPI_RW(reg);       // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
 163   1              for(i=0; i<bytes; i++)
 164   1              SPI_RW(pBuf[i]);        // Öð¸ö×Ö½ÚÐ´ÈënRF24L01
 165   1              CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 166   1              return(status);             // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 167   1      }
 168          /**************************************************/
 169          
 170          /**************************************************
 171          º¯Êý£ºRX_Mode()
 172          
 173          ÃèÊö£º
 174              Õâ¸öº¯ÊýÉèÖÃnRF24L01Îª½ÓÊÕÄ£Ê½£¬µÈ´ý½ÓÊÕ·¢ËÍÉè±¸µÄÊý¾Ý°ü
 175          /**************************************************/
 176          void RX_Mode(void)
 177          {
 178   1                      CE = 0;
 179   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH);  // ½ÓÊÕÉè±¸½ÓÊÕÍ¨µÀ0Ê¹ÓÃºÍ·¢ËÍÉè±¸ÏàÍ
C51 COMPILER V9.01   MAIN                                                                  06/10/2012 00:20:04 PAGE 4   

             -¬µÄ·¢ËÍµØÖ·
 180   1              SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);               // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0×Ô¶¯Ó¦´ð
 181   1              SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);           // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0
 182   1              SPI_RW_Reg(WRITE_REG + SETUP_AW, 0x02);                    //ÉèÖÃµØÖ·¿í¶È 1:0 00-ÎÞÐ§ 01-3×Ö½Ú 10-4×Ö½Ú 11 5×Ö½Ú
 183   1                      SPI_RW_Reg(WRITE_REG + RF_CH, 0);                 // Ñ¡ÔñÉäÆµÍ¨µÀ0x40
 184   1              SPI_RW_Reg(WRITE_REG + RX_PW_P0, TX_PLOAD_WIDTH);  // ½ÓÊÕÍ¨µÀ0Ñ¡ÔñºÍ·¢ËÍÍ¨µÀÏàÍ¬ÓÐÐ§Êý¾Ý¿í¶È
 185   1              SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x0F);            // Êý¾Ý´«ÊäÂÊ1Mbps£¬·¢Éä¹¦ÂÊ0dBm£¬µÍÔëÉù·Å´óÆ÷ÔöÒæ
 186   1              SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f);              // CRCÊ¹ÄÜ£¬16Î»CRCÐ£Ñé£¬ÉÏµç£¬½ÓÊÕÄ£Ê½
 187   1              CE = 1;                                            // À­¸ßCEÆô¶¯½ÓÊÕÉè±¸
 188   1              while(delay--);
 189   1              delay = 150;
 190   1      
 191   1      }
 192          /**************************************************/
 193          
 194          /**************************************************
 195          º¯Êý£ºTX_Mode()
 196          
 197          ÃèÊö£º
 198              Õâ¸öº¯ÊýÉèÖÃnRF24L01Îª·¢ËÍÄ£Ê½£¬£¨CE=1³ÖÐøÖÁÉÙ10us£©£¬
 199                  130usºóÆô¶¯·¢Éä£¬Êý¾Ý·¢ËÍ½áÊøºó£¬·¢ËÍÄ£¿é×Ô¶¯×ªÈë½ÓÊÕ
 200                  Ä£Ê½µÈ´ýÓ¦´ðÐÅºÅ¡£
 201          /**************************************************/
 202          void TX_Mode(uchar * BUF)
 203          {
 204   1              CE = 0;
 205   1              SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);     // Ð´Èë·¢ËÍµØÖ·
 206   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH);  // ÎªÁËÓ¦´ð½ÓÊÕÉè±¸£¬½ÓÊÕÍ¨µÀ0µØÖ·ºÍ·
             -¢ËÍµØÖ·ÏàÍ¬
 207   1              SPI_Write_Buf(WR_TX_PLOAD, BUF, TX_PLOAD_WIDTH);                  // Ð´Êý¾Ý°üµ½TX FIFO
 208   1              SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);       // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0×Ô¶¯Ó¦´ð
 209   1              SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);   // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0
 210   1              SPI_RW_Reg(WRITE_REG + SETUP_AW, 0x02);         //ÉèÖÃµØÖ·¿í¶È 1:0 00-ÎÞÐ§ 01-3×Ö½Ú 10-4×Ö½Ú 11 5×Ö½Ú
 211   1              SPI_RW_Reg(WRITE_REG + SETUP_RETR, 0x0a);  // ×Ô¶¯ÖØ·¢ÑÓÊ±µÈ´ý250us+86us£¬×Ô¶¯ÖØ·¢10´Î
 212   1              SPI_RW_Reg(WRITE_REG + RF_CH, 0);         // Ñ¡ÔñÉäÆµÍ¨µÀ0x40
 213   1              SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x0F);    // Êý¾Ý´«ÊäÂÊ2Mbps£¬·¢Éä¹¦ÂÊ0dBm£¬µÍÔëÉù·Å´óÆ÷ÔöÒæ
 214   1              SPI_RW_Reg(WRITE_REG + CONFIG, 0x0e);      // CRCÊ¹ÄÜ£¬16Î»CRCÐ£Ñé£¬ÉÏµç
 215   1              CE = 1;
 216   1              while(delay--);
 217   1              delay = 150;
 218   1      }
 219          /**************************************************/
 220          
 221          /**************************************************
 222          º¯Êý£ºCheck_ACK()
 223          
 224          ÃèÊö£º
 225              ¼ì²é½ÓÊÕÉè±¸ÓÐÎÞ½ÓÊÕµ½Êý¾Ý°ü£¬Éè¶¨Ã»ÓÐÊÕµ½Ó¦´ðÐÅ
 226                  ºÅÊÇ·ñÖØ·¢
 227          /**************************************************/
 228          uchar Check_ACK(bit clear)
 229          {
 230   1              send_string("µÈ´ýirqÖÐ¶Ï");
 231   1              while(IRQ);
 232   1              send_string("ÖÐ¶Ïºó");
 233   1              sta = SPI_Read(STATUS);
 234   1              //sta = SPI_RW(NOP);
 235   1              if(TX_DS)//Êý¾Ý·¢ËÍÍê³ÉÖÐ¶Ï¡£µ±Êý¾Ý·¢ËÍÍê³Éºó²úÉúÖÐ¶Ï¡£Èç¹û¹¤×÷ÔÚ×Ô¶¯Ó¦´ðÄ£Ê½ÏÂÖ»ÓÐµ±½ÓÊÕµ½Ó¦´ðÐÅºÅºóÖÃ1
 236   1                      send_char('T');
 237   1              else
 238   1                      send_char('F');                    // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 239   1              if(MAX_RT){
C51 COMPILER V9.01   MAIN                                                                  06/10/2012 00:20:04 PAGE 5   

 240   2                      if(clear){                                      // ÊÇ·ñÇå³ýTX FIFO£¬Ã»ÓÐÇå³ýÔÚ¸´Î»MAX_RTÖÐ¶Ï±êÖ¾ºóÖØ·¢
 241   3                      send_string("´ïµ½×î´óÖØ·¢Êý");
 242   3                      //send_char(SPI_Read(OBSERVE_TX));                     
 243   3                              SPI_RW(FLUSH_TX);
 244   3                      }
 245   2              }
 246   1              SPI_RW_Reg(WRITE_REG + STATUS, sta);  // Çå³ýTX_DS»òMAX_RTÖÐ¶Ï±êÖ¾
 247   1              IRQ = 1;   
 248   1              if(TX_DS)//Êý¾Ý·¢ËÍÍê³ÉÖÐ¶Ï¡£µ±Êý¾Ý·¢ËÍÍê³Éºó²úÉúÖÐ¶Ï¡£Èç¹û¹¤×÷ÔÚ×Ô¶¯Ó¦´ðÄ£Ê½ÏÂÖ»ÓÐµ±½ÓÊÕµ½Ó¦´ðÐÅºÅºóÖÃ1
 249   1                      return(0x54);
 250   1              else
 251   1                      return(0x46);
 252   1      }
 253          /**************************************************/
 254          
 255          /**************************************************
 256          º¯Êý£ºCheckButtons()
 257          
 258          ÃèÊö£º
 259              ¼ì²é°´¼üÊÇ·ñ°´ÏÂ£¬°´ÏÂÔò·¢ËÍÒ»×Ö½ÚÊý¾Ý
 260          /**************************************************/
 261          void CheckButtons()
 262          {
 263   1      
 264   1                              TX_BUF[0] = DATA;          // Êý¾ÝËÍµ½»º´æ
 265   1                              TX_Mode(TX_BUF);                        // °ÑnRF24L01ÉèÖÃÎª·¢ËÍÄ£Ê½²¢·¢ËÍÊý¾Ý
 266   1                              //LED = ~DATA;                  // Êý¾ÝËÍµ½LEDÏÔÊ¾
 267   1                              send_char(Check_ACK(1));               // µÈ´ý·¢ËÍÍê±Ï£¬Çå³ýTX FIFO
 268   1                              //delay_ms(250);
 269   1                              //delay_ms(250);
 270   1                              //LED = 0xff;                           // ¹Ø±ÕLED
 271   1                              RX_Mode();                              // ÉèÖÃÎª½ÓÊÕÄ£Ê½
 272   1                              //while(!(P3 & 0x01));
 273   1                              //DATA <<= 1;
 274   1                              //if(!DATA)
 275   1                              //      DATA = 0x26;
 276   1              
 277   1      }
 278          /**************************************************/
 279          
 280          /**************************************************
 281          º¯Êý£ºmain()
 282          
 283          ÃèÊö£º
 284              Ö÷º¯Êý
 285          /**************************************************/
 286          void main(void)
 287          {
 288   1              uart_init();
 289   1              init_io();                            // ³õÊ¼»¯IO
 290   1              RX_Mode();              
 291   1              while(1)
 292   1              {
 293   2                       
 294   2                      while(RI)
 295   2                      {         DATA = read_char();
 296   3                                CheckButtons();           // °´¼üÉ¨Ãè
 297   3                      }
 298   2                      
 299   2                      sta = SPI_Read(STATUS);   // ¶Á×´Ì¬¼Ä´æÆ÷
 300   2                       if(RX_DR)                                // ÅÐ¶ÏÊÇ·ñ½ÓÊÜµ½Êý¾Ý
 301   2                      {
C51 COMPILER V9.01   MAIN                                                                  06/10/2012 00:20:04 PAGE 6   

 302   3                              //send_string("ÊÕµ½Êý¾Ý");
 303   3                              send_char('&');
 304   3                              SPI_Read_Buf(RD_RX_PLOAD, RX_BUF, TX_PLOAD_WIDTH);  // ´ÓRX FIFO¶Á³öÊý¾Ý
 305   3                              flag = 1;
 306   3                      }
 307   2                      SPI_RW_Reg(WRITE_REG + STATUS, sta);  // Çå³ýRX_DSÖÐ¶Ï±êÖ¾
 308   2                      if(flag)                           // ½ÓÊÜÍê³É
 309   2                      {
 310   3                              flag = 0;                      // Çå±êÖ¾
 311   3                              send_char(RX_BUF[0]);
 312   3                              send_char(';');
 313   3                      }
 314   2              }
 315   1      }
 316          /**************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    597    ----
   CONSTANT SIZE    =     36    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     46      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
