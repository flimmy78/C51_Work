C51 COMPILER V9.01   18B20TEST                                                             07/03/2011 11:32:32 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE 18B20TEST
OBJECT MODULE PLACED IN .\18B20TEST.obj
COMPILER INVOKED BY: C:\ccc\Keil\C51\BIN\C51.EXE C:\Users\Thinkpad\Desktop\18B20TEST.C BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\18B20TEST.lst) OBJECT(.\18B20TEST.obj)

line level    source

   1          //DS18B20温度检测及其液晶显示
   2          #include<reg52.h>    //包含单片机寄存器的头文件
   3          #include<intrins.h>  //包含_nop_()函数定义的头文件
   4          unsigned char code table[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};//定义共阳数码管显示字型码 
   5          unsigned char flag,tltemp;
   6          sbit fmq=P3^6;
   7           sbit jdq=P3^7;
   8          void delay500us()
   9          {
  10   1      
  11   1      unsigned char j;
  12   1      
  13   1       for(j=0;j<57;j++)        //500us基准延时程序 
  14   1       {
  15   2        ;
  16   2       } 
  17   1      }
  18          
  19          void beep()     //产生1KHZ频率声音的函数
  20          {
  21   1              fmq=0;
  22   1              delay500us();
  23   1              fmq=1;
  24   1              delay500us();   
  25   1      
  26   1      }
  27          /*****************************************************
  28          函数功能：延时1ms
  29          (3j+2)*i=(3×33+2)×10=1010(微秒)，可以认为是1毫秒
  30          ***************************************************/
  31          void delay1ms()
  32          {
  33   1         unsigned char i,j;   
  34   1               for(i=0;i<4;i++)
  35   1                for(j=0;j<33;j++)
  36   1                 ;             
  37   1       }
  38          /*****************************************************
  39          函数功能：延时若干毫秒
  40          入口参数：n
  41          ***************************************************/
  42           void delaynms(unsigned char n)
  43           {
  44   1         unsigned char i;
  45   1              for(i=0;i<n;i++)
  46   1                 delay1ms();
  47   1       }
  48          
  49          /*****************************************************
  50          函数功能：将模式设置指令或显示地址写入液晶模块
  51          入口参数：dictate
  52          **************************************************
  53          void WriteInstruction (unsigned char dictate)
  54          {   
C51 COMPILER V9.01   18B20TEST                                                             07/03/2011 11:32:32 PAGE 2   

  55              while(BusyTest()==1);   //如果忙就等待
  56                   RS=0;                  //根据规定，RS和R/W同时为低电平时，可以写入指令
  57                   RW=0;   
  58                   E=0;                   //E置低电平(根据表8-6，写指令时，E为高脉冲，
  59                                     // 就是让E从0到1发生正跳变，所以应先置"0"
  60                   _nop_();
  61                   _nop_();               //空操作两个机器周期，给硬件反应时间
  62                   P0=dictate;            //将数据送入P0口，即写入指令或地址
  63                   _nop_();
  64                   _nop_();
  65                   _nop_();
  66                   _nop_();               //空操作四个机器周期，给硬件反应时间
  67                   E=1;                   //E置高电平
  68                   _nop_();
  69                   _nop_();
  70                   _nop_();
  71                   _nop_();               //空操作四个机器周期，给硬件反应时间
  72                    E=0;                  //当E由高电平跳变成低电平时，液晶模块开始执行命令
  73           } */
  74            void display_temp1(unsigned char x)
  75          {
  76   1                                unsigned char i=255;
  77   1       unsigned char j,k,l;     //j,k,l分别储存温度的百位、十位和个位
  78   1                      j=x/100;
  79   1                      k=(x%100)/10;
  80   1                      l=x%10; 
  81   1                      if(k>=3)
  82   1                      jdq=0;
  83   1                      else
  84   1                      jdq=1;
  85   1              while(i--){
  86   2                                    //取百位
  87   2                      P0=table[j];
  88   2                      P2=0xfe;
  89   2                      delaynms(5);
  90   2                       
  91   2                      P0=table[k];
  92   2                      P2=0xfd;
  93   2                      delaynms(5);
  94   2                      
  95   2                      P0=table[l];
  96   2                      P2=0xfb; 
  97   2                      delaynms(5);
  98   2                        if(k>=3)
  99   2                      beep();
 100   2              }
 101   1              
 102   1              P2=0xff;
 103   1              
 104   1      }
 105          
 106          /************************************************************************
 107          以下是DS18B20的操作程序
 108           ************************************************************************/ 
 109          sbit DQ=P3^3;
 110          unsigned char time;   //设置全局变量，专门用于严格延时
 111          /*****************************************************
 112          函数功能：将DS18B20传感器初始化，读取应答信号
 113          出口参数：flag 
 114          ***************************************************/
 115          bit Init_DS18B20(void)  
 116          {
C51 COMPILER V9.01   18B20TEST                                                             07/03/2011 11:32:32 PAGE 3   

 117   1       bit flag;         //储存DS18B20是否存在的标志，flag=0，表示存在；flag=1，表示不存在
 118   1       DQ = 1;           //先将数据线拉高
 119   1       for(time=0;time<2;time++) //略微延时约6微秒
 120   1           ;
 121   1       DQ = 0;           //再将数据线从高拉低，要求保持480~960us
 122   1       for(time=0;time<200;time++)  //略微延时约600微秒
 123   1           ;         //以向DS18B20发出一持续480~960us的低电平复位脉冲 
 124   1       DQ = 1;           //释放数据线（将数据线拉高） 
 125   1        for(time=0;time<10;time++)
 126   1           ;  //延时约30us（释放总线后需等待15~60us让DS18B20输出存在脉冲）
 127   1       flag=DQ;          //让单片机检测是否输出了存在脉冲（DQ=0表示存在）      
 128   1       for(time=0;time<200;time++)  //延时足够长时间，等待存在脉冲输出完毕
 129   1            ;
 130   1       return (flag);    //返回检测成功标志
 131   1      }
 132          /*****************************************************
 133          函数功能：从DS18B20读取一个字节数据
 134          出口参数：dat
 135          ***************************************************/ 
 136          unsigned char ReadOneChar(void)
 137           {
 138   1                      unsigned char i=0;      
 139   1                      unsigned char dat;  //储存读出的一个字节数据
 140   1                      for (i=0;i<8;i++)
 141   1                       {
 142   2                         
 143   2                         DQ =1;       // 先将数据线拉高
 144   2                         _nop_();         //等待一个机器周期   
 145   2                         DQ = 0;      //单片机从DS18B20读书据时,将数据线从高拉低即启动读时序
 146   2                         _nop_();     //等待一个机器周期                 
 147   2                         DQ = 1;     //将数据线"人为"拉高,为单片机检测DS18B20的输出电平作准备
 148   2                         for(time=0;time<2;time++)
 149   2                   ;      //延时约6us，使主机在15us内采样
 150   2                                      dat>>=1;
 151   2                         if(DQ==1)
 152   2                            dat|=0x80;  //如果读到的数据是1，则将1存入dat
 153   2                              else
 154   2                                      dat|=0x00;//如果读到的数据是0，则将0存入dat
 155   2                           //将单片机检测到的电平信号DQ存入r[i]       
 156   2                         for(time=0;time<8;time++)
 157   2                              ;              //延时3us,两个读时序之间必须有大于1us的恢复期    
 158   2                  }                       
 159   1               return(dat);    //返回读出的十六进制数据
 160   1      }
 161          /*****************************************************
 162          函数功能：向DS18B20写入一个字节数据
 163          入口参数：dat
 164          ***************************************************/  
 165          WriteOneChar(unsigned char dat)
 166          {
 167   1              unsigned char i=0;
 168   1              for (i=0; i<8; i++)
 169   1                       {
 170   2                        DQ =1;         // 先将数据线拉高
 171   2                        _nop_();           //等待一个机器周期  
 172   2                        DQ=0;          //将数据线从高拉低时即启动写时序       
 173   2                        DQ=dat&0x01;   //利用与运算取出要写的某位二进制数据,
 174   2                             //并将其送到数据线上等待DS18B20采样      
 175   2                       for(time=0;time<10;time++)     
 176   2                           ;//延时约30us，DS18B20在拉低后的约15~60us期间从数据线上采样
 177   2                        DQ=1;          //释放数据线               
 178   2                        for(time=0;time<1;time++)
C51 COMPILER V9.01   18B20TEST                                                             07/03/2011 11:32:32 PAGE 4   

 179   2                                ;//延时3us,两个写时序间至少需要1us的恢复期
 180   2                        dat>>=1;       //将dat中的各二进制位数据右移1位
 181   2                       }
 182   1                for(time=0;time<4;time++)
 183   1                            ; //稍作延时,给硬件一点反应时间
 184   1      }
 185          
 186          /*****************************************************
 187          函数功能：做好读温度的准备
 188          ***************************************************/ 
 189          void ReadyReadTemp(void)
 190          {
 191   1              Init_DS18B20();     //将DS18B20初始化
 192   1                      WriteOneChar(0xCC); // 跳过读序号列号的操作
 193   1                      WriteOneChar(0x44); // 启动温度转换       
 194   1                    delaynms(200); //转换一次需要延时一段时间 
 195   1              
 196   1                      Init_DS18B20();     //将DS18B20初始化
 197   1                      WriteOneChar(0xCC); //跳过读序号列号的操作
 198   1                      WriteOneChar(0xBE); //读取温度寄存器,前两个分别是温度的低位和高位       
 199   1      }
 200          
 201          
 202          
 203          
 204          /******************************************************************************
 205          以下是与温度有关的显示设置
 206           ******************************************************************************/
 207           /*****************************************************
 208          函数功能：显示没有检测到DS18B20
 209          ***************************************************/   
 210          void display_error(void)
 211           {
 212   1            /* unsigned char i;
 213   1                           WriteAddress(0x00);    //写显示地址，将在第1行第1列开始显示
 214   1                                 i = 0;                //从第一个字符开始显示
 215   1                                      while(Error[i] != '\0')  //只要没有写到结束标志，就继续写
 216   1                                      {                                               
 217   1                                              WriteData(Error[i]);   //将字符常量写入LCD
 218   1                                              i++;                 //指向下一个字符
 219   1                                              delaynms(100);        //延时100ms较长时间，以看清关于显示的说明
 220   1                                      }       
 221   1                              
 222   1                           WriteAddress(0x40);    //写显示地址，将在第1行第1列开始显示
 223   1                                 i = 0;                //从第一个字符开始显示
 224   1                                      while(Error1[i] != '\0')  //只要没有写到结束标志，就继续写
 225   1                                      {                                               
 226   1                                              WriteData(Error1[i]);   //将字符常量写入LCD
 227   1                                              i++;                 //指向下一个字符
 228   1                                              delaynms(100);        //延时100ms较长时间，以看清关于显示的说明
 229   1                                      }       
 230   1                                      while(1)              //进入死循环，等待查明原因
 231   1                                        ;*/
 232   1      }
 233          /*****************************************************
 234          函数功能：显示说明信息
 235          **************************************************   
 236          void display_explain(void)
 237           {
 238                 unsigned char i;
 239                               WriteAddress(0x00);    //写显示地址，将在第1行第1列开始显示
 240                                     i = 0;                //从第一个字符开始显示
C51 COMPILER V9.01   18B20TEST                                                             07/03/2011 11:32:32 PAGE 5   

 241                                          while(Str[i] != '\0')  //只要没有写到结束标志，就继续写
 242                                          {                                               
 243                                                  WriteData(Str[i]);   //将字符常量写入LCD
 244                                                  i++;                 //指向下一个字符
 245                                                  delaynms(100);        //延时100ms较长时间，以看清关于显示的说明
 246                                          }       
 247          }*/
 248          /*****************************************************
 249          函数功能：显示温度符号
 250          **************************************************   
 251          void display_symbol(void)
 252           {
 253                 unsigned char i;
 254                               WriteAddress(0x40);    //写显示地址，将在第2行第1列开始显示
 255                                     i = 0;                //从第一个字符开始显示
 256                                          while(Temp[i] != '\0')  //只要没有写到结束标志，就继续写
 257                                          {                                               
 258                                                  WriteData(Temp[i]);   //将字符常量写入LCD
 259                                                  i++;                 //指向下一个字符
 260                                                  delaynms(50);        //延时1ms给硬件一点反应时间
 261                                          }       
 262          }*/
 263          
 264          /*****************************************************
 265          函数功能：显示温度的小数点
 266          **************************************************   
 267          void    display_dot(void)
 268          {         
 269                   WriteAddress(0x49);      //写显示地址，将在第2行第10列开始显示            
 270                   WriteData('.');      //将小数点的字符常量写入LCD
 271                   delaynms(50);         //延时1ms给硬件一点反应时间              
 272          }*/
 273          /*****************************************************
 274          函数功能：显示温度的单位(Cent)
 275          **************************************************   
 276          void    display_cent(void)
 277          {
 278                     unsigned char i;    
 279                               WriteAddress(0x4c);        //写显示地址，将在第2行第13列开始显示   
 280                                     i = 0;                    //从第一个字符开始显示 
 281                                          while(Cent[i] != '\0')     //只要没有写到结束标志，就继续写
 282                                          {                                       
 283                                                  WriteData(Cent[i]);     //将字符常量写入LCD
 284                                                  i++;                 //指向下一个字符
 285                                                  delaynms(50);        //延时1ms给硬件一点反应时间
 286                                          }       
 287          }*/
 288          /*****************************************************
 289          函数功能：显示温度的整数部分
 290          入口参数：x
 291          ************************************************** 
 292          void display_temp1(unsigned char x)
 293          {
 294           unsigned char j,k,l;     //j,k,l分别储存温度的百位、十位和个位
 295                  j=x/100;              //取百位
 296                  k=(x%100)/10;    //取十位
 297                  l=x%10;             //取个位  
 298                  WriteAddress(0x46);    //写显示地址,将在第2行第7列开始显示
 299                  if(flag==1)                             //负温度时 显示“―”
 300                  {
 301                  WriteData(digit[10]);    //将百位数字的字符常量写入LCD
 302                                                                                                                    
C51 COMPILER V9.01   18B20TEST                                                             07/03/2011 11:32:32 PAGE 6   

             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                      }
 303                  else{
 304                  WriteData(digit[j]);    //将十位数字的字符常量写入LCD
 305                  }
 306                  WriteData(digit[k]);    //将十位数字的字符常量写入LCD
 307                  WriteData(digit[l]);    //将个位数字的字符常量写入LCD
 308                  delaynms(50);         //延时1ms给硬件一点反应时间     
 309           }        */
 310           /*****************************************************
 311          函数功能：显示温度的小数数部分
 312          入口参数：x
 313          ************************************************** 
 314           void display_temp2(unsigned char x)
 315          {
 316                  WriteAddress(0x4a);      //写显示地址,将在第2行第11列开始显示
 317                  WriteData(digit[x]);     //将小数部分的第一位数字字符常量写入LCD
 318                  delaynms(50);          //延时1ms给硬件一点反应时间
 319          }
 320            */
 321          /*****************************************************
 322          函数功能：主函数
 323          ***************************************************/ 
 324          
 325           void main(void)
 326          
 327           {        
 328   1                unsigned char TL;     //储存暂存器的温度低位
 329   1                unsigned char TH;    //储存暂存器的温度高位
 330   1            unsigned char TN;      //储存温度的整数部分
 331   1                unsigned char TD;       //储存温度的小数部分
 332   1              //  LcdInitiate();         //将液晶初始化
 333   1                 delaynms(5);        //延时5ms给硬件一点反应时间      
 334   1                      if(Init_DS18B20()==1)
 335   1                  display_error();
 336   1      
 337   1                      //display_explain();
 338   1         //   display_symbol();    //显示温度说明
 339   1          //  display_dot();       //显示温度的小数点
 340   1          //  display_cent();      //显示温度的单位
 341   1         while(1)                //不断检测并显示温度
 342   1               {       flag=0;
 343   2                      ReadyReadTemp();     //读温度准备
 344   2      
 345   2                  TL=ReadOneChar();    //先读的是温度值低位
 346   2                      TH=ReadOneChar();    //接着读的是温度值高位
 347   2                      
 348   2                      if((TH&0xf8)!=0x00)//判断高五位 得到温度正负标志
 349   2                      {
 350   3                              flag=1;
 351   3                              TL=~TL;  //取反
 352   3                              TH=~TH;   //取反
 353   3                              tltemp=TL+1; //低位加1
C51 COMPILER V9.01   18B20TEST                                                             07/03/2011 11:32:32 PAGE 7   

 354   3                              TL=tltemp;
 355   3                              if(tltemp>255) TH++;  //如果低8位大于255，向高8位进1
 356   3                         TN=TH*16+TL/16;      //实际温度值=(TH*256+TL)/16,即：TH*16+TL/16
 357   3                                                                                //这样得出的是温度的整数部分,小数部分被丢弃了
 358   3                         TD=(TL%16)*10/16;    //计算温度的小数部分,将余数乘以10再除以16取整，
 359   3                      }
 360   2                      TN=TH*16+TL/16;      //实际温度值=(TH*256+TL)/16,即：TH*16+TL/16
 361   2                                                        //这样得出的是温度的整数部分,小数部分被丢弃了
 362   2                 TD=(TL%16)*10/16;    //计算温度的小数部分,将余数乘以10再除以16取整，
 363   2                                                //这样得到的是温度小数部分的第一位数字(保留1位小数)
 364   2                 display_temp1(TN);    //显示温度的整数部分
 365   2               //  display_temp2(TD);    //显示温度的小数部分
 366   2            delaynms(10);               
 367   2          }   
 368   1                                
 369   1      }
 370          
 371          
 372          
 373          
 374          
*** WARNING C290 IN LINE 184 OF C:\USERS\THINKPAD\DESKTOP\18B20TEST.C: missing return value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    476    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
